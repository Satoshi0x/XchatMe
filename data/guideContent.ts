import { Section } from '../types';

export const guideData: Section[] = [
  {
    id: "prerequisites",
    title: "Prerequisites",
    description: "We are switching to a 100% Free Tier stack. No credit card required for setup.",
    steps: [
      {
        title: "1. Accounts Needed",
        actionItems: [
          "GitHub Account (to host backend code).",
          "Render.com Account (Free Web Service for Node.js).",
          "Supabase.com Account (Free PostgreSQL Database)."
        ]
      },
      {
        title: "2. X (Twitter) Developer Keys",
        actionItems: [
          "Create App in X Developer Portal.",
          "Set Callback URI to: https://[YOUR-RENDER-URL].onrender.com/auth/callback",
          "Set Website URL to: https://xchatter.me",
          "Copy Client ID & Client Secret."
        ]
      }
    ]
  },
  {
    id: "phase-1",
    title: "Phase 1: The Database",
    description: "We use Supabase (PostgreSQL) for real-time chat logs and storage.",
    steps: [
      {
        title: "Create Table in Supabase",
        description: "Navigate to Supabase -> SQL Editor -> New Query:",
        code: {
            language: "sql",
            code: `CREATE TABLE messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  room_url TEXT NOT NULL,
  username TEXT NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Index for faster querying by room
CREATE INDEX idx_messages_room ON messages(room_url);`
        },
        actionItems: [
            "Run the query.",
            "Go to Project Settings -> API.",
            "Copy the 'Project URL' and 'service_role' secret."
        ]
      }
    ]
  },
  {
    id: "phase-2",
    title: "Phase 2: The Backend",
    description: "Deploy a Node.js WebSocket server on Render to handle real-time connections.",
    steps: [
      {
        title: "1. Create Project",
        code: {
          language: "bash",
          code: `mkdir xchatter-backend
cd xchatter-backend
npm init -y
npm install express ws cors @supabase/supabase-js dotenv`
        }
      },
      {
        title: "2. src/index.js",
        description: "The main server file handling WebSockets and Auth.",
        code: {
          language: "javascript",
          filename: "src/index.js",
          code: `const express = require('express');
const { WebSocketServer } = require('ws');
const { createClient } = require('@supabase/supabase-js');
const http = require('http');

const app = express();
const server = http.createServer(app);
const wss = new WebSocketServer({ server });

// Database Connection
const supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY);

// Active Rooms (In-memory)
const rooms = new Map(); // Map<siteUrl, Set<ws>>

// 1. WebSocket Logic
wss.on('connection', (ws, req) => {
  const urlParams = new URLSearchParams(req.url.split('?')[1]);
  const site = urlParams.get('site') || 'unknown';

  if (!rooms.has(site)) rooms.set(site, new Set());
  rooms.get(site).add(ws);

  ws.on('message', async (message) => {
    const data = JSON.parse(message);
    
    // Broadcast to Room
    const clients = rooms.get(site);
    for (const client of clients) {
      if (client.readyState === 1) client.send(JSON.stringify(data));
    }

    // Persist to Supabase
    await supabase.from('messages').insert({
      room_url: site,
      username: data.username || 'Anon',
      content: data.text
    });
  });

  ws.on('close', () => {
    if (rooms.has(site)) {
      rooms.get(site).delete(ws);
      if (rooms.get(site).size === 0) rooms.delete(site);
    }
  });
});

// 2. Stats Endpoint
app.get('/stats/top', (req, res) => {
  const sorted = Array.from(rooms.entries())
    .map(([site, clients]) => ({ site, count: clients.size }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);
  res.json(sorted);
});

// 3. OAuth Login Redirect
app.get('/auth/login', (req, res) => {
  const xUrl = \`https://twitter.com/i/oauth2/authorize?response_type=code&client_id=\${process.env.X_CLIENT_ID}&redirect_uri=\${process.env.REDIRECT_URI}&scope=tweet.read%20users.read&state=state&code_challenge=challenge&code_challenge_method=plain\`;
  res.redirect(xUrl);
});

// 4. OAuth Callback
app.get('/auth/callback', async (req, res) => {
  const { code } = req.query;
  const tokenParams = new URLSearchParams({
    code,
    grant_type: "authorization_code",
    client_id: process.env.X_CLIENT_ID,
    redirect_uri: process.env.REDIRECT_URI,
    code_verifier: "challenge"
  });

  const response = await fetch("https://api.twitter.com/2/oauth2/token", {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      "Authorization": "Basic " + btoa(process.env.X_CLIENT_ID + ":" + process.env.X_CLIENT_SECRET)
    },
    body: tokenParams
  });

  const data = await response.json();
  
  res.send(\`
    <html><body><script>
      chrome.runtime.sendMessage("\${process.env.EXTENSION_ID}", { 
        type: "AUTH_SUCCESS", 
        token: "\${data.access_token}" 
      });
      window.close();
    </script></body></html>
  \`);
});

server.listen(process.env.PORT || 3000, () => {
  console.log('Server started');
});`
        }
      },
      {
        title: "3. Deploy to Render",
        actionItems: [
          "Push code to GitHub.",
          "New Web Service on Render.",
          "Build: npm install",
          "Start: node src/index.js",
          "Environment Variables: SUPABASE_URL, SUPABASE_KEY, X_CLIENT_ID, X_CLIENT_SECRET, EXTENSION_ID, REDIRECT_URI."
        ]
      }
    ]
  },
  {
    id: "phase-3",
    title: "Phase 3: The Frontend",
    description: "Chrome Extension (Vite + React) connected to your Render backend.",
    steps: [
      {
        title: "1. Create Project",
        code: {
          language: "bash",
          code: `npm create vite@latest xchatter-frontend -- --template react-ts
cd xchatter-frontend
npm install lucide-react tailwindcss postcss autoprefixer
npx tailwindcss init -p`
        }
      },
      {
        title: "2. public/manifest.json",
        description: "Extension manifest allowing connection to your backend.",
        code: {
          language: "json",
          filename: "public/manifest.json",
          code: `{
  "manifest_version": 3,
  "name": "XchatterME",
  "version": "1.0",
  "permissions": ["storage", "activeTab", "scripting"],
  "host_permissions": ["https://*.onrender.com/*"], 
  "background": { "service_worker": "background.js" },
  "action": {}, 
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["src/content.tsx"],
      "run_at": "document_idle"
    }
  ]
}`
        }
      },
      {
        title: "3. Connect to Backend (src/App.tsx)",
        description: "Point the extension to your Render URL and handle user storage.",
        code: {
          language: "typescript",
          filename: "src/App.tsx (Snippet)",
          code: `// YOUR RENDER URL
const API_URL = "https://your-app.onrender.com";

// WebSocket
const ws = new WebSocket(\`wss://your-app.onrender.com?site=\${site}\`);

// Login Function
function login() {
  window.open(\`\${API_URL}/auth/login\`, "XAuth", "width=500,height=600");
}

// Listen for Auth Success from Background Script
chrome.runtime.onMessage.addListener((msg) => {
  if (msg.type === "AUTH_SUCCESS") {
     // Fetch User Profile from X API (via proxy or direct if configured)
     fetch("https://api.twitter.com/2/users/me", { 
        headers: { Authorization: \`Bearer \${msg.token}\` } 
     })
     .then(r => r.json())
     .then(data => {
        // STORE USERNAME LOCALLY
        const username = data.data.username;
        chrome.storage.local.set({ username: username });
     });
  }
});`
        }
      }
    ]
  }
];